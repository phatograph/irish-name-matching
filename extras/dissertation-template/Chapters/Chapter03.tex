\chapter{Name matching algorithms}
\label{ch:nma}

This chapter describes the details how the project is implemented.
Note that algorithms and codes listed here are written in Ruby programming language,
which is the main language of the project.

We will start off by detailing bundled matching algorithms here.
Each matching algorithm calculates the \emph{similarity score} between
two strings.

The score is ranging between 0.0 to 1.0, where 0.0 means
two strings are completely different and 1.0 means both are extactly matched.

Also note that string inputs here is in all in the uppercase format,
in order to prevent letter-case difference.

\section{Levenshtein distance}
\label{sec:leven}

This algorithm measures the difference between two strings.
It tells the minimum number of opearations needed to change string to
another. These opeations are insertions, deletions, or substitutions.
Consider these following examples.

\begin{itemize}
  \item SM\textbf{I}TH $\rightarrow$ SM\textbf{Y}TH \\
    the minimum operation to change is 1, which is to substitute \emph{I} to
    \emph{Y}, therefore Levenshtein distance for these two strings is 1.
  \item GOWAN $\rightarrow$ \textbf{MC}GOWAN \\
    2 insertions of \emph{M} and \emph{C} is required.
  \item SM\textbf{I}TH\textbf{E} $\rightarrow$ SM\textbf{Y}TH \\
    1 deletion of \emph{e} and 1 substitution of \emph{i} to \emph{y} are required.
\end{itemize}

The implementation used in the project is done by \citet{textgem}\footnote{levenshtein.rb}.
Once the distance is calculated, it will be compared to the length of
the longer string between the two (or if they are the same length,
use that length).

For example, Levenshtein distance between \emph{SMYTH} and \emph{SMITHE}
is 2, compare 2 to length of the longer string, \emph{SMITHE}, which is 6.
So the \emph{similarity score} of these two strings are $6 - (2 / 6) = 0.667$.

The code of this algorithm is as in listing \ref{lst:leven}, note that
\texttt{\@name} and \texttt{@base\_name.name} are two strings to be matched.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label={lst:leven}, caption={Levenshtein distance implementation.}]
def cal_score
  @value = Text::Levenshtein.distance(@name, @base_name.name)
  size   = [@name.size, @base_name.name.size].max
  @score = ((size - @value).to_f / size)
end
\end{lstlisting}
\end{minipage}

\section{Soundex}
\label{sub:soundex}

Soundex encodes a string into a 4 character code representing
an essence of its sound as pronounced in English. It operates
in the following steps.

\begin{enumerate}
  \item Take the first letter of a string.
  \item Encode each remaining letters into a group following table \ref{table:soundex}.
    Discards A, E, I, O, U, H, W, and Y
  \item Remove two adjacent same characters.
  \item If a group of a first letter is the same as the second letter,
    remove the second letter.
  \item Trim or pad with zeros as necessary, making the result 4 characters long.
\end{enumerate}

\begin{table}
  \myfloatalign
  \setlength{\tabcolsep}{0.3cm}
  \begin{tabular}{c p{5cm}}
    \toprule
    \tableheadline{Group} & \tableheadline{Letters} \\
    \midrule
    1 & B, F, P, V \\
    2 & C, G, J, K, Q, S, X, Z \\
    3 & D, T \\
    4 & L \\
    5 & M, N \\
    6 & R \\
    - & A, E, I, O, U, H, W, Y \\
    \bottomrule
  \end{tabular}
  \caption{Soundex letter group.}
  \label{table:soundex}
\end{table}

Let us follow these steps by step, consider we are going to encode the string
\emph{PFISTTER}.

\begin{enumerate}
  \item Take first letter of \emph{PFISTTER}. \\
    PFISTTER $\rightarrow$ P
  \item Encode remaining letter \emph{FISTTER}. \\
    PFISTTER $\rightarrow$ P1-233-6 $\rightarrow$ P12336
  \item Remove two adjacent same characters. \\
    PFISTTER $\rightarrow$ P12336 $\rightarrow$ P1236
  \item P is also in group 1, so remove the second 1 letter. \\
    PFISTTER $\rightarrow$ P1236 $\rightarrow$ P236
  \item P236 is 4 characters long, so no need to be trimmed or padded. \\
    PFISTTER $\rightarrow$ P1236 $\rightarrow$ P236
\end{enumerate}

Therefore, soundex of \emph{PFISTTER} is \texttt{P236}.

The implementation of soundex (listing \ref{lst:soundex}) in this project is adapted from
\citeauthor{adamw}\textquotesingle s \emph{Irish soundex} implementated in Visual Basic\footnote{\cite{adamw} Appendix 3.}.
The code is commented following the same aforementioned steps.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label={lst:soundex}, caption={Soundex implementation.}]
def self.soundex(name)
  # Take the first letter of a string.
  result = name.first

  # Encode remaining letters
  name[1..name.length].split('').each do |n|
    result = result + category(n).to_s
  end

  # Remove two adjacent same characters
  result.gsub!(/([0-9])\1+/, '\1')

  # If category of 1st letter equals 2nd character, remove 2nd character
  if result.size >= 2 && category(result[0]).to_s == result[1]
    result.slice!(1)
  end

  # Trim or pad with zeros as necessary
  result = if result.size == 4
             result
           elsif result.size > 4
             result[0..3]
           else
             result.ljust(4, '0')
           end
end
\end{lstlisting}
\end{minipage}

The \texttt{category} function implements soundex grouping table (table \ref{table:soundex})
as in listing \ref{lst:soundexc}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label={lst:soundexc}, caption={Soundex grouping table implementation.}]
def self.category(c)
  if c.match(/[AEIOUHWY]/).present?
    ""
  elsif c.match(/[BPFV]/).present?
    1
  elsif c.match(/[CSKGJQXZ]/).present?
    2
  elsif c.match(/[DT]/).present?
    3
  elsif c.match(/[L]/).present?
    4
  elsif c.match(/[MN]/).present?
    5
  elsif c.match(/[R]/).present?
    6
  else
    ""
  end
end
\end{lstlisting}
\end{minipage}

Now that we encode two strings to be matched in soundexes.
We then calculate the \emph{similarity score} of these two soundexes using
these steps.

\begin{itemize}
  \item Compare first characters of each soundex, if they are different,
    \emph{similarity score} is 0, otherwise move to next step.
  \item Compare the rest 3 digits by using Levenshtein distance (section \ref{sec:leven})
    to calculate the distance between them.
\end{itemize}

For example, \emph{similarity score} between \emph{SMITH} and \emph{SPEED},
which soundexes are \texttt{S530} and \texttt{S130} respectively,
is 0.75 (1 substitution from \emph{5} to \emph{1}, so 1 difference of length 4).

The code of this soundex \emph{similarity score} is as in listing \ref{lst:sds}.

\begin{minipage}{\linewidth}
  \begin{lstlisting}[label={lst:sds}, caption={Soundex similarity score implementation.}]
def soundex_distance_score(s1, s2)
  if s1.first != s2.first
    0  # Different category, so they suppose to be completely different
  else
    (s1.size - Text::Levenshtein.distance(s1, s2).to_f ) / s1.size
  end
end
\end{lstlisting}
\end{minipage}

\section{Irish soundex}

Irish soundex is another variant of traditional soundex. It determines
characteristics of Irish names and normalised them to modern names.
This algorithm also follows \citeauthor{adamw}\textquotesingle s
\emph{Irish soundex}\footnote{\cite{adamw} Appendix 3.}.

Irish names might contain some prefix, e.g. \emph{Mc} or \emph{O},
which are obstructive to soundex result. These prefixes are to be
discarded. Moreover, there is no initial soft \emph{C} in Irish names,
instead \emph{K} is used. So the first letter \emph{C} is changed to \emph{K}.
It is implemented as in listing \ref{lst:irishsoundex}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label={lst:irishsoundex}, caption={Irish soundex implementation.}]
def self.soundex(name)
  # Change initial ST. to SAINT
  name = name.match(/^ST\./).present? ? "SAINT #{name[3..name.length]}" : name

  # Discard Irish prefixes
  name = if name.match(/^O /).present?
           name[1..name.length].gsub(' ', '')
         elsif name.match(/^O'/).present?
           name[2..name.length].gsub(' ', '')
         elsif name.match(/^MC/).present?
           name[2..name.length].gsub(' ', '')
         elsif name.match(/^M'/).present?
           name[2..name.length].gsub(' ', '')
         elsif name.match(/^MAC/).present? && name != 'MAC'
           name[3..name.length].gsub(' ', '')
         else
           name
         end

  # Change initial C to K
  name = name.strip.gsub(/^C/, 'K')

  # Call to traditional soundex.
  return {
    :label => name,
    :soundex => Soundex.soundex(name)
  }
end
\end{lstlisting}
\end{minipage}

Irish soundex algorithm in this project calls traditional soundex
described in section \ref{sub:soundex} to minimise repeated code.
It also calculates \emph{similarity score} the same way
soundex does, as in listing \ref{lst:sds}.

\section{Lookup table}

Lookup table is constructed from Robert Edwin Matheson\textquotesingle s
classification of Irish names. All classification information
is stored in a Database, using PostgreSQL, which is a powerful,
open source object-relational database system \cite[]{postgresql}.

Matheson classified the surnames in Ireland into 2091 groups.
Each group has one or more names, and on the other hand,
each name belongs to one or more group.

In this section, we will consider the names as strings input.
So the term \emph{string} will be used in consistent with
previous sections.

For example, considering the string \emph{ACHESON}, this string
belongs to two groups, 4 and 42. So \emph{ACHESON} will have
2 records in the database. One with reference to group 4
and another with reference to group 42.

Next, let us consider group 4 and 42.

\begin{quotation} \noindent
4 $\rightarrow$ ACHESON, ACHISON, AITCHISON, ATCHESON, ATCHIESON, ATCHISON, ATKINSON \\
42 $\rightarrow$ ACHESON, ARKESON, ATKINS, ATKINSON
\end{quotation}

By combining two groups together, these are all possible strings
that match \emph{ACHESON} according to Matheson\textquotesingle s classification.

Now is the process to match two strings using Lookup table,
suppose two strings are \emph{ACHESON} and \emph{ATKINS}.

\begin{enumerate}
  \item Find references of \emph{ACHESON}. We get references for group 4 and 42.
    Note the use of \texttt{pluck} method to select reference attribute (\texttt{ref})
    here\footnote{Use pluck as a shortcut to select one or more attributes
      without loading a bunch of records just to grab the attributes you want.
    \url{http://api.rubyonrails.org/classes/ActiveRecord/Calculations.html\#method-i-pluck}}.
    \begin{lstlisting}
    LookupTableRecord.where(:name => 'ACHESON').pluck(:ref)
    => [4, 42]
    \end{lstlisting}
  \item Find reference to matching string \emph{ATKINS} and also specify
    the reference groups from step 1. If there is no match \texttt{where} method
    will return empty array. \texttt{present?} method is used to
    check the result if it is not empty\footnote{\url{http://api.rubyonrails.org/classes/Object.html\#method-i-present-3F}}.
    \begin{lstlisting}
    LookupTableRecord.where(:ref => [4, 42], :name => 'ATKINS').present?
    => true
    \end{lstlisting}
    By specifying both matching string and references group, we can ensure
    the matching name is also in the one of the same reference group
    of the base name. In this case, we conclude that there is a match
    between \emph{ACHESON} and \emph{ATKINS} via group 4 or 42
    (or more specifically, 42, because \emph{ATKINS} belongs to group 41 and 42).
\end{enumerate}

If a reference is found on both steps, \emph{similarity score} for lookup table
of the two strings is 1.0. If the system fails to find any reference on
any step, consider a no match and the score is 0.0.

By following these steps, the implementation of lookup table
is as in lisiting \ref{lst:lookup}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label={lst:lookup}, caption={Lookup table implementation.}]
def cal_score
  # Look for a reference for base name
  base = LookupTableRecord.where(:name => @base_name.name)

  @score = if base.nil?  # Could not find reference for base name, no matches
             0
           else
             # Find any reference that has 1) same name 2) same reference
             base = base.map(&:ref)
             refs = LookupTableRecord.where(:ref => base, :name => @name)

             if refs.present?
               @label = (base & refs.map(&:ref)).join(', ')
               @value = "Matched"
               1
             else  # Could not find reference for matching name, no matches
               0
             end
           end
end
\end{lstlisting}
\end{minipage}
