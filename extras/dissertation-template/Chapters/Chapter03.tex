\chapter{Solution}
\label{ch:solution}

This chapter describes the details how the project is implemented.
Note that algorithms and codes listed here are written in Ruby programming language,
which is the main language of the project.

\section{Name matching algorithms}

We will start off by detailing bundled matching algorithms here.
Each matching algorithm calculates the \emph{similarity score} between
two strings. The score is ranging between 0.0 to 1.0, where 0.0 means
two strings are completely different and 1.0 means both are extactly matched.

\subsection{Levenshtein distance}
\label{sub:leven}

This algorithm measures the difference between two strings.
It tells the minimum number of opearations needed to change string to
another. These opeations are insertions, deletions, or substitutions.
Consider these following examples.

\begin{itemize}
  \item Sm\textbf{i}th $\rightarrow$ Sm\textbf{y}th \\
    the minimum operation to change is 1, which is to substitute \emph{i} to
    \emph{y}, therefore Levenshtein distance for these two strings is 1.
  \item Gowan $\rightarrow$ \textbf{Mc}Gowan \\
    2 insertions of \emph{M} and \emph{c} is required.
  \item Sm\textbf{i}th\textbf{e} $\rightarrow$ Sm\textbf{y}th \\
    1 deletion of \emph{e} and 1 substitution of \emph{i} to \emph{y} are required.
\end{itemize}

The implementation used in the project is done by \citet{textgem}\footnote{levenshtein.rb}.
Once the distance is calculated, it will be compared to the length of
the longer string between the two (or if they are the same length,
use that length).

For example, Levenshtein distance between \emph{Smyth} and \emph{Smithe}
is 2, compare 2 to length of the longer string, \emph{Smithe}, which is 6.
So the \emph{similarity score} of these two strings are $6 - (2 / 6) = 0.667$.

The code of this algorithm is as in listing \ref{lst:leven}, note that
\texttt{\@name} and \texttt{@base\_name.name} are two strings to be matched.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label={lst:leven}, caption={Levenshtein distance implementation.}]
def cal_score
  @value = Text::Levenshtein.distance(@name, @base_name.name)
  size   = [@name.size, @base_name.name.size].max
  @score = ((size - @value).to_f / size)
end
\end{lstlisting}
\end{minipage}

\subsection{Soundex}
\label{sub:soundex}

Soundex encodes a string into a 4 character code representing
an essence of its sound as pronounced in English. It operates
in the following steps.

\begin{enumerate}
  \item Take the first letter of a string.
  \item Encode each remaining letters into a group following table \ref{table:soundex}.
    Discards A, E, I, O, U, H, W, and Y
  \item Remove two adjacent same characters.
  \item If a group of a first letter is the same as the second letter,
    remove the second letter.
  \item Trim or pad with zeros as necessary, making the result 4 characters long.
\end{enumerate}

\begin{table}
  \myfloatalign
  \setlength{\tabcolsep}{0.3cm}
  \begin{tabular}{c p{5cm}}
    \toprule
    \tableheadline{Group} & \tableheadline{Letters} \\
    \midrule
    1 & B, F, P, V \\
    2 & C, G, J, K, Q, S, X, Z \\
    3 & D, T \\
    4 & L \\
    5 & M, N \\
    6 & R \\
    - & A, E, I, O, U, H, W, Y \\
    \bottomrule
  \end{tabular}
  \caption{Soundex letter group.}
  \label{table:soundex}
\end{table}

Let us follow these steps by step, consider we are going to encode the string
\emph{PFISTTER}.

\begin{enumerate}
  \item Take first letter of \emph{PFISTTER}. \\
    PFISTTER $\rightarrow$ P
  \item Encode remaining letter \emph{FISTTER}. \\
    PFISTTER $\rightarrow$ P1-233-6 $\rightarrow$ P12336
  \item Remove two adjacent same characters. \\
    PFISTTER $\rightarrow$ P12336 $\rightarrow$ P1236
  \item P is also in group 1, so remove the second 1 letter. \\
    PFISTTER $\rightarrow$ P1236 $\rightarrow$ P236
  \item P236 is 4 characters long, so no need to be trimmed or padded. \\
    PFISTTER $\rightarrow$ P1236 $\rightarrow$ P236
\end{enumerate}

Therefore, soundex of \emph{PFISTTER} is \texttt{P236}.

The implementation of soundex (listing \ref{lst:soundex}) in this project is adapted from
\citeauthor{adamw}\textquotesingle s \emph{Irish soundex} implementated in Visual Basic\footnote{\cite{adamw} Appendix 3.}.
The code is commented following the same aforementioned steps.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label={lst:soundex}, caption={Soundex implementation.}]
def self.soundex(name)
  # Take the first letter of a string.
  result = name.first

  # Encode remaining letters
  name[1..name.length].split('').each do |n|
    result = result + category(n).to_s
  end

  # Remove two adjacent same characters
  result.gsub!(/([0-9])\1+/, '\1')

  # If category of 1st letter equals 2nd character, remove 2nd character
  if result.size >= 2 && category(result[0]).to_s == result[1]
    result.slice!(1)
  end

  # Trim or pad with zeros as necessary
  result = if result.size == 4
             result
           elsif result.size > 4
             result[0..3]
           else
             result.ljust(4, '0')
           end
end
\end{lstlisting}
\end{minipage}

The \texttt{category} function implements soundex grouping table (table \ref{table:soundex})
as in listing \ref{lst:soundexc}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label={lst:soundexc}, caption={Soundex grouping table implementation.}]
def self.category(c)
  if c.match(/[AEIOUHWY]/).present?
    ""
  elsif c.match(/[BPFV]/).present?
    1
  elsif c.match(/[CSKGJQXZ]/).present?
    2
  elsif c.match(/[DT]/).present?
    3
  elsif c.match(/[L]/).present?
    4
  elsif c.match(/[MN]/).present?
    5
  elsif c.match(/[R]/).present?
    6
  else
    ""
  end
end
\end{lstlisting}
\end{minipage}

Now that we encode two strings to be matched in soundexes.
We then calculate the \emph{similarity score} of these two soundexes using
these steps.

\begin{itemize}
  \item Compare first characters of each soundex, if they are different,
    \emph{similarity score} is 0, otherwise move to next step.
  \item Compare the rest 3 digits by using Levenshtein distance (section \ref{sub:leven})
    to calculate the distance between them.
\end{itemize}

For example, \emph{similarity score} between \emph{Smith} and \emph{Speed},
which soundexes are \texttt{S530} and \texttt{S130} respectively,
is 0.75 (1 substitution from \emph{5} to \emph{1}, so 1 difference of length 4).

The code of this soundex \emph{similarity score} is as in listing \ref{lst:sds}.

\begin{minipage}{\linewidth}
  \begin{lstlisting}[label={lst:sds}, caption={Soundex similarity score implementation.}]
def soundex_distance_score(s1, s2)
  if s1.first != s2.first
    0  # Different category, so they suppose to be completely different
  else
    (s1.size - Text::Levenshtein.distance(s1, s2).to_f ) / s1.size
  end
end
\end{lstlisting}
\end{minipage}

\subsection{Irish soundex}

Irish soundex is another variant of traditional soundex. It determines
characteristics of Irish names and normalised them to modern names.
This algorithm also follows \citeauthor{adamw}\textquotesingle s
\emph{Irish soundex}\footnote{\cite{adamw} Appendix 3.}.

Irish names might contain some prefix, e.g. \emph{Mc} or \emph{O},
which are obstructive to soundex result. These prefixes are to be
discarded. Moreover, there is no initial soft \emph{C} in Irish names,
instead \emph{K} is used. So the first letter \emph{C} is changed to \emph{K}.
It is implemented as in listing \ref{lst:irishsoundex}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label={lst:irishsoundex}, caption={Irish soundex implementation.}]
def self.soundex(name)
  # Change initial ST. to SAINT
  name = name.match(/^ST\./).present? ? "SAINT #{name[3..name.length]}" : name

  # Discard Irish prefixes
  name = if name.match(/^O /).present?
           name[1..name.length].gsub(' ', '')
         elsif name.match(/^O'/).present?
           name[2..name.length].gsub(' ', '')
         elsif name.match(/^MC/).present?
           name[2..name.length].gsub(' ', '')
         elsif name.match(/^M'/).present?
           name[2..name.length].gsub(' ', '')
         elsif name.match(/^MAC/).present? && name != 'MAC'
           name[3..name.length].gsub(' ', '')
         else
           name
         end

  # Change initial C to K
  name = name.strip.gsub(/^C/, 'K')

  # Call to traditional soundex.
  return {
    :label => name,
    :soundex => Soundex.soundex(name)
  }
end
\end{lstlisting}
\end{minipage}

Irish soundex algorithm in this project calls traditional soundex
described in section \ref{sub:soundex} to minimise repeated code.
It also calculates \emph{similarity score} the same way
soundex does, as in listing \ref{lst:sds}.
