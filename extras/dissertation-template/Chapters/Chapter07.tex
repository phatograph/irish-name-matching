\chapter{Conclusion}
\label{ch:conclusion}

We successfully developed an extensible web service system to match names.
The system is initially encoded with 4 matching algorithms,
Levenshtein distance, soundex, Irish soundex, and lookup table.
We also present a web interface for a client to use the system
from the web browser.

The system is designed to be extended with simple inheritance, thus a developer
can understand and develop further algorithm easily. In early state
simple design is enough to serve the purpose, so we follow the
\emph{Kiss principle} \cite[]{kiss}.

However, we have encountered some problem, also there are still much room
for future works. We will describe these in the following sections.

\section{Encountered problem}

The major problem is that the current system takes too long to process
and also uses too much memory. It has not been properly optimised
in terms of performance. These following techniques might improve
our system furthermore.

\subsection{Memoization}

Memoization is the process of storing a computed value to avoid
duplicated work by repetitive calls. While each algorithm calculats
\emph{similarity score}, there might be many repetitive calculations
or database queries.

Ruby has a conditional assignment operator \texttt{\textbar \textbar =} \cite[]{cao}
which is commonly used for memoization. By doing so, it can improve
performance of the system and reduce the number of database calls \cite[]{memoization},
thus shorten response time and lower memory usage.

\subsection{find\_in\_batches}
Matching large amount of name causes high memory consumption and may lead to
out of memory situlation, especially in environment which memory are crucial
and expensive such as on a remote server.

Rails provides \texttt{find\_in\_batches} which operates an array in batches,
thus greatly reducing memory consumption \cite[]{fib}. We can apply
the same principle to our \emph{base name} and \emph{to-match name},
also to the \emph{controller} (section \ref{sec:mvc}).

\subsection{Replace RDBMS with NoSQL}

Current database system (section \ref{sec:testenv}) is a
\emph{Relational database management system (RDBMS)} \cite[]{rdbms} and the system
relies on traditional database queries. By replacing this with high speed
NoSQL database such as Redis \cite[]{redis}, which is one of the fastest
NoSQL \cite[]{redis2}, we can obtain better performance while using
lookup table algorithm.

\section{Future works}

Our system can be further enhanced in many mays. Here are sample ideas
for upcoming features of the system.

\subsection{More phonetic algorithms}

A phonetic algorithm \cite[]{phonea} indexes words by their pronunciation.
Soundex is one of them. We can implement more matching algorithms
based on them. For example, Kolner Phonetik \cite[]{kolner} is similar to
soundex and works well on German words. Daitch-Mokotoff soundex \cite[]{dms}
is an improved soundex working well to match surnames of Slavic and Germanic origin.

\subsection{Inheritance for similar matching algorithms}

Currently all matching algorithms inherit \texttt{MatchingAlgorithm} class.
In future, if there are many similar ones or can be categorised in the
same group, we can create another level of inheritance so they can share
common methods. For example, consider the soundex case, with Kolner Phonetik
and Daitch-Mokotoff soundex we can create inheritance with \texttt{Soundex} class
as in listing \ref{lst:sd_in}.

\begin{minipage}{\linewidth}
  \begin{lstlisting}[label={lst:sd_in}, caption={\texttt{Soundex} inheritance.}]
class Soundex < MatchingAlgorithm
  WEIGHT = 3

  def self.soundex(name)
  ..
  end

  private

  def self.category(c)
  ..
  end

  def cal_score
  ..
  end

  # Moved from MatchingAlgorithm class to be more specific to soundexes.
  def soundex_distance_score(s1, s2)
  ..
  end
end

class IrishSoundex < Soundex
..
end

class KolnerPhonetik < Soundex
..
end

class DaitchMokotoffSoundex < Soundex
..
end
\end{lstlisting}
\end{minipage}

\subsection{Improve web interface result}

Current web interface result is as in figure \ref{fig:wi_res}, just
a list of boxes detailed with matching algorithm scores. When it
comes to large number of inputs, thousands of boxes will be generated
and could overwhelm both browser and client themselves.

We can improve result display by implement a visualised graph base on
the results, there are many libraries \cite[]{chart} that are capable
if generating interactive graph. d3js is another well option for
starting from scratch.
